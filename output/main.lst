
output/main.elf:     file format elf32-littlearm


Disassembly of section .text:

0800001c <delay>:
#include "stm32f103x_registers.h"
#include "FreeRTOS.h"
#include "task.h"

void delay() {
 800001c:	b480      	push	{r7}
 800001e:	b083      	sub	sp, #12
 8000020:	af00      	add	r7, sp, #0
    for (int i = 0; i < 1000000; ++i);
 8000022:	2300      	movs	r3, #0
 8000024:	607b      	str	r3, [r7, #4]
 8000026:	e002      	b.n	800002e <delay+0x12>
 8000028:	687b      	ldr	r3, [r7, #4]
 800002a:	3301      	adds	r3, #1
 800002c:	607b      	str	r3, [r7, #4]
 800002e:	687b      	ldr	r3, [r7, #4]
 8000030:	4a03      	ldr	r2, [pc, #12]	; (8000040 <delay+0x24>)
 8000032:	4293      	cmp	r3, r2
 8000034:	ddf8      	ble.n	8000028 <delay+0xc>
}
 8000036:	bf00      	nop
 8000038:	370c      	adds	r7, #12
 800003a:	46bd      	mov	sp, r7
 800003c:	bc80      	pop	{r7}
 800003e:	4770      	bx	lr
 8000040:	000f423f 	.word	0x000f423f

08000044 <task1>:

static void task1(void* args)
{
 8000044:	b580      	push	{r7, lr}
 8000046:	b082      	sub	sp, #8
 8000048:	af00      	add	r7, sp, #0
 800004a:	6078      	str	r0, [r7, #4]
    int i;
    // Toggle Pin 13 (LED)
    GPIOC->ODR ^= (1 << 13);
 800004c:	4a05      	ldr	r2, [pc, #20]	; (8000064 <task1+0x20>)
 800004e:	4b05      	ldr	r3, [pc, #20]	; (8000064 <task1+0x20>)
 8000050:	68db      	ldr	r3, [r3, #12]
 8000052:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8000056:	60d3      	str	r3, [r2, #12]
    delay();
 8000058:	f7ff ffe0 	bl	800001c <delay>
    /*for(i = 0; i < 1000000; i++)
    {
        __asm__("nop");
    } */
}
 800005c:	bf00      	nop
 800005e:	3708      	adds	r7, #8
 8000060:	46bd      	mov	sp, r7
 8000062:	bd80      	pop	{r7, pc}
 8000064:	40011000 	.word	0x40011000

08000068 <main>:

int main() {
 8000068:	b580      	push	{r7, lr}
 800006a:	b084      	sub	sp, #16
 800006c:	af04      	add	r7, sp, #16
    // Enable GPIOC clock
    RCC->APB2ENR |= (1 << 4);
 800006e:	4a11      	ldr	r2, [pc, #68]	; (80000b4 <main+0x4c>)
 8000070:	4b10      	ldr	r3, [pc, #64]	; (80000b4 <main+0x4c>)
 8000072:	699b      	ldr	r3, [r3, #24]
 8000074:	f043 0310 	orr.w	r3, r3, #16
 8000078:	6193      	str	r3, [r2, #24]

    // Configure Pin 13 as Output (LED)
    GPIOC->CRH |= (1 << 20);  // Set mode bits for Pin 13
 800007a:	4a0f      	ldr	r2, [pc, #60]	; (80000b8 <main+0x50>)
 800007c:	4b0e      	ldr	r3, [pc, #56]	; (80000b8 <main+0x50>)
 800007e:	685b      	ldr	r3, [r3, #4]
 8000080:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000084:	6053      	str	r3, [r2, #4]
    GPIOC->CRH &= ~(1 << 21);
 8000086:	4a0c      	ldr	r2, [pc, #48]	; (80000b8 <main+0x50>)
 8000088:	4b0b      	ldr	r3, [pc, #44]	; (80000b8 <main+0x50>)
 800008a:	685b      	ldr	r3, [r3, #4]
 800008c:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8000090:	6053      	str	r3, [r2, #4]

    xTaskCreate(task1,"LED",100,NULL,configMAX_PRIORITIES-1,NULL);
 8000092:	2300      	movs	r3, #0
 8000094:	9303      	str	r3, [sp, #12]
 8000096:	2300      	movs	r3, #0
 8000098:	9302      	str	r3, [sp, #8]
 800009a:	2300      	movs	r3, #0
 800009c:	9301      	str	r3, [sp, #4]
 800009e:	2304      	movs	r3, #4
 80000a0:	9300      	str	r3, [sp, #0]
 80000a2:	2300      	movs	r3, #0
 80000a4:	2264      	movs	r2, #100	; 0x64
 80000a6:	4905      	ldr	r1, [pc, #20]	; (80000bc <main+0x54>)
 80000a8:	4805      	ldr	r0, [pc, #20]	; (80000c0 <main+0x58>)
 80000aa:	f000 f9af 	bl	800040c <xTaskGenericCreate>
	vTaskStartScheduler();
 80000ae:	f000 fa55 	bl	800055c <vTaskStartScheduler>
	for (;;);
 80000b2:	e7fe      	b.n	80000b2 <main+0x4a>
 80000b4:	40021000 	.word	0x40021000
 80000b8:	40011000 	.word	0x40011000
 80000bc:	08000010 	.word	0x08000010
 80000c0:	08000045 	.word	0x08000045

080000c4 <Reset_Handler>:
    (uint32_t *)Default_Handler, // Hard fault
    // Other interrupt service routine (ISR) entries...
};
*/

void Reset_Handler(void) {
 80000c4:	b580      	push	{r7, lr}
 80000c6:	b082      	sub	sp, #8
 80000c8:	af00      	add	r7, sp, #0
    // Copy initialized data section from Flash to RAM
    uint32_t *source = &_sidata;
 80000ca:	4b10      	ldr	r3, [pc, #64]	; (800010c <Reset_Handler+0x48>)
 80000cc:	607b      	str	r3, [r7, #4]
    uint32_t *destination = &_sdata;
 80000ce:	4b10      	ldr	r3, [pc, #64]	; (8000110 <Reset_Handler+0x4c>)
 80000d0:	603b      	str	r3, [r7, #0]

    while (destination < &_edata) {
 80000d2:	e007      	b.n	80000e4 <Reset_Handler+0x20>
        *destination++ = *source++;
 80000d4:	683b      	ldr	r3, [r7, #0]
 80000d6:	1d1a      	adds	r2, r3, #4
 80000d8:	603a      	str	r2, [r7, #0]
 80000da:	687a      	ldr	r2, [r7, #4]
 80000dc:	1d11      	adds	r1, r2, #4
 80000de:	6079      	str	r1, [r7, #4]
 80000e0:	6812      	ldr	r2, [r2, #0]
 80000e2:	601a      	str	r2, [r3, #0]
    while (destination < &_edata) {
 80000e4:	683b      	ldr	r3, [r7, #0]
 80000e6:	4a0b      	ldr	r2, [pc, #44]	; (8000114 <Reset_Handler+0x50>)
 80000e8:	4293      	cmp	r3, r2
 80000ea:	d3f3      	bcc.n	80000d4 <Reset_Handler+0x10>
    }

    // Initialize BSS section to zero
    destination = &_sbss;
 80000ec:	4b0a      	ldr	r3, [pc, #40]	; (8000118 <Reset_Handler+0x54>)
 80000ee:	603b      	str	r3, [r7, #0]
    while (destination < &_ebss) {
 80000f0:	e004      	b.n	80000fc <Reset_Handler+0x38>
        *destination++ = 0;
 80000f2:	683b      	ldr	r3, [r7, #0]
 80000f4:	1d1a      	adds	r2, r3, #4
 80000f6:	603a      	str	r2, [r7, #0]
 80000f8:	2200      	movs	r2, #0
 80000fa:	601a      	str	r2, [r3, #0]
    while (destination < &_ebss) {
 80000fc:	683b      	ldr	r3, [r7, #0]
 80000fe:	4a07      	ldr	r2, [pc, #28]	; (800011c <Reset_Handler+0x58>)
 8000100:	4293      	cmp	r3, r2
 8000102:	d3f6      	bcc.n	80000f2 <Reset_Handler+0x2e>
    }

    // Call the main function
    main();
 8000104:	f7ff ffb0 	bl	8000068 <main>

    // Infinite loop to prevent falling through
    while (1);
 8000108:	e7fe      	b.n	8000108 <Reset_Handler+0x44>
 800010a:	bf00      	nop
 800010c:	08000aac 	.word	0x08000aac
 8000110:	20000000 	.word	0x20000000
 8000114:	2000000c 	.word	0x2000000c
 8000118:	20000010 	.word	0x20000010
 800011c:	2000150c 	.word	0x2000150c

08000120 <Default_Handler>:
}

void Default_Handler(void) {
 8000120:	b480      	push	{r7}
 8000122:	af00      	add	r7, sp, #0
    while (1);
 8000124:	e7fe      	b.n	8000124 <Default_Handler+0x4>
	...

08000128 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8000128:	b580      	push	{r7, lr}
 800012a:	b08a      	sub	sp, #40	; 0x28
 800012c:	af00      	add	r7, sp, #0
 800012e:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 8000130:	2300      	movs	r3, #0
 8000132:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
 8000134:	f000 fa40 	bl	80005b8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 8000138:	4b47      	ldr	r3, [pc, #284]	; (8000258 <pvPortMalloc+0x130>)
 800013a:	681b      	ldr	r3, [r3, #0]
 800013c:	2b00      	cmp	r3, #0
 800013e:	d118      	bne.n	8000172 <pvPortMalloc+0x4a>
		{
			prvHeapInit();
 8000140:	4b46      	ldr	r3, [pc, #280]	; (800025c <pvPortMalloc+0x134>)
 8000142:	4a47      	ldr	r2, [pc, #284]	; (8000260 <pvPortMalloc+0x138>)
 8000144:	601a      	str	r2, [r3, #0]
 8000146:	4b45      	ldr	r3, [pc, #276]	; (800025c <pvPortMalloc+0x134>)
 8000148:	2200      	movs	r2, #0
 800014a:	605a      	str	r2, [r3, #4]
 800014c:	4b45      	ldr	r3, [pc, #276]	; (8000264 <pvPortMalloc+0x13c>)
 800014e:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
 8000152:	605a      	str	r2, [r3, #4]
 8000154:	4b43      	ldr	r3, [pc, #268]	; (8000264 <pvPortMalloc+0x13c>)
 8000156:	2200      	movs	r2, #0
 8000158:	601a      	str	r2, [r3, #0]
 800015a:	4b41      	ldr	r3, [pc, #260]	; (8000260 <pvPortMalloc+0x138>)
 800015c:	617b      	str	r3, [r7, #20]
 800015e:	697b      	ldr	r3, [r7, #20]
 8000160:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
 8000164:	605a      	str	r2, [r3, #4]
 8000166:	697b      	ldr	r3, [r7, #20]
 8000168:	4a3e      	ldr	r2, [pc, #248]	; (8000264 <pvPortMalloc+0x13c>)
 800016a:	601a      	str	r2, [r3, #0]
			xHeapHasBeenInitialised = pdTRUE;
 800016c:	4b3a      	ldr	r3, [pc, #232]	; (8000258 <pvPortMalloc+0x130>)
 800016e:	2201      	movs	r2, #1
 8000170:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 8000172:	687b      	ldr	r3, [r7, #4]
 8000174:	2b00      	cmp	r3, #0
 8000176:	d00e      	beq.n	8000196 <pvPortMalloc+0x6e>
		{
			xWantedSize += heapSTRUCT_SIZE;
 8000178:	2310      	movs	r3, #16
 800017a:	461a      	mov	r2, r3
 800017c:	687b      	ldr	r3, [r7, #4]
 800017e:	4413      	add	r3, r2
 8000180:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8000182:	687b      	ldr	r3, [r7, #4]
 8000184:	f003 0307 	and.w	r3, r3, #7
 8000188:	2b00      	cmp	r3, #0
 800018a:	d004      	beq.n	8000196 <pvPortMalloc+0x6e>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800018c:	687b      	ldr	r3, [r7, #4]
 800018e:	f023 0307 	bic.w	r3, r3, #7
 8000192:	3308      	adds	r3, #8
 8000194:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
 8000196:	687b      	ldr	r3, [r7, #4]
 8000198:	2b00      	cmp	r3, #0
 800019a:	d056      	beq.n	800024a <pvPortMalloc+0x122>
 800019c:	687b      	ldr	r3, [r7, #4]
 800019e:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 80001a2:	d252      	bcs.n	800024a <pvPortMalloc+0x122>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 80001a4:	4b2d      	ldr	r3, [pc, #180]	; (800025c <pvPortMalloc+0x134>)
 80001a6:	623b      	str	r3, [r7, #32]
			pxBlock = xStart.pxNextFreeBlock;
 80001a8:	4b2c      	ldr	r3, [pc, #176]	; (800025c <pvPortMalloc+0x134>)
 80001aa:	681b      	ldr	r3, [r3, #0]
 80001ac:	627b      	str	r3, [r7, #36]	; 0x24
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
 80001ae:	e004      	b.n	80001ba <pvPortMalloc+0x92>
			{
				pxPreviousBlock = pxBlock;
 80001b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80001b2:	623b      	str	r3, [r7, #32]
				pxBlock = pxBlock->pxNextFreeBlock;
 80001b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80001b6:	681b      	ldr	r3, [r3, #0]
 80001b8:	627b      	str	r3, [r7, #36]	; 0x24
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
 80001ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80001bc:	685a      	ldr	r2, [r3, #4]
 80001be:	687b      	ldr	r3, [r7, #4]
 80001c0:	429a      	cmp	r2, r3
 80001c2:	d203      	bcs.n	80001cc <pvPortMalloc+0xa4>
 80001c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80001c6:	681b      	ldr	r3, [r3, #0]
 80001c8:	2b00      	cmp	r3, #0
 80001ca:	d1f1      	bne.n	80001b0 <pvPortMalloc+0x88>
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 80001cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80001ce:	4a25      	ldr	r2, [pc, #148]	; (8000264 <pvPortMalloc+0x13c>)
 80001d0:	4293      	cmp	r3, r2
 80001d2:	d03a      	beq.n	800024a <pvPortMalloc+0x122>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 80001d4:	6a3b      	ldr	r3, [r7, #32]
 80001d6:	681b      	ldr	r3, [r3, #0]
 80001d8:	2210      	movs	r2, #16
 80001da:	4413      	add	r3, r2
 80001dc:	61fb      	str	r3, [r7, #28]

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80001de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80001e0:	681a      	ldr	r2, [r3, #0]
 80001e2:	6a3b      	ldr	r3, [r7, #32]
 80001e4:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80001e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80001e8:	685a      	ldr	r2, [r3, #4]
 80001ea:	687b      	ldr	r3, [r7, #4]
 80001ec:	1ad3      	subs	r3, r2, r3
 80001ee:	2210      	movs	r2, #16
 80001f0:	0052      	lsls	r2, r2, #1
 80001f2:	4293      	cmp	r3, r2
 80001f4:	d922      	bls.n	800023c <pvPortMalloc+0x114>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 80001f6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80001f8:	687b      	ldr	r3, [r7, #4]
 80001fa:	4413      	add	r3, r2
 80001fc:	613b      	str	r3, [r7, #16]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80001fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000200:	685a      	ldr	r2, [r3, #4]
 8000202:	687b      	ldr	r3, [r7, #4]
 8000204:	1ad2      	subs	r2, r2, r3
 8000206:	693b      	ldr	r3, [r7, #16]
 8000208:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
 800020a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800020c:	687a      	ldr	r2, [r7, #4]
 800020e:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 8000210:	693b      	ldr	r3, [r7, #16]
 8000212:	685b      	ldr	r3, [r3, #4]
 8000214:	60fb      	str	r3, [r7, #12]
 8000216:	4b11      	ldr	r3, [pc, #68]	; (800025c <pvPortMalloc+0x134>)
 8000218:	61bb      	str	r3, [r7, #24]
 800021a:	e002      	b.n	8000222 <pvPortMalloc+0xfa>
 800021c:	69bb      	ldr	r3, [r7, #24]
 800021e:	681b      	ldr	r3, [r3, #0]
 8000220:	61bb      	str	r3, [r7, #24]
 8000222:	69bb      	ldr	r3, [r7, #24]
 8000224:	681b      	ldr	r3, [r3, #0]
 8000226:	685a      	ldr	r2, [r3, #4]
 8000228:	68fb      	ldr	r3, [r7, #12]
 800022a:	429a      	cmp	r2, r3
 800022c:	d3f6      	bcc.n	800021c <pvPortMalloc+0xf4>
 800022e:	69bb      	ldr	r3, [r7, #24]
 8000230:	681a      	ldr	r2, [r3, #0]
 8000232:	693b      	ldr	r3, [r7, #16]
 8000234:	601a      	str	r2, [r3, #0]
 8000236:	69bb      	ldr	r3, [r7, #24]
 8000238:	693a      	ldr	r2, [r7, #16]
 800023a:	601a      	str	r2, [r3, #0]
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
 800023c:	4b0a      	ldr	r3, [pc, #40]	; (8000268 <pvPortMalloc+0x140>)
 800023e:	681a      	ldr	r2, [r3, #0]
 8000240:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000242:	685b      	ldr	r3, [r3, #4]
 8000244:	1ad3      	subs	r3, r2, r3
 8000246:	4a08      	ldr	r2, [pc, #32]	; (8000268 <pvPortMalloc+0x140>)
 8000248:	6013      	str	r3, [r2, #0]
			}
		}
	}
	xTaskResumeAll();
 800024a:	f000 f9c3 	bl	80005d4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 800024e:	69fb      	ldr	r3, [r7, #28]
}
 8000250:	4618      	mov	r0, r3
 8000252:	3728      	adds	r7, #40	; 0x28
 8000254:	46bd      	mov	sp, r7
 8000256:	bd80      	pop	{r7, pc}
 8000258:	20001420 	.word	0x20001420
 800025c:	20001410 	.word	0x20001410
 8000260:	20000010 	.word	0x20000010
 8000264:	20001418 	.word	0x20001418
 8000268:	20000000 	.word	0x20000000

0800026c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 800026c:	b580      	push	{r7, lr}
 800026e:	b086      	sub	sp, #24
 8000270:	af00      	add	r7, sp, #0
 8000272:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
 8000274:	687b      	ldr	r3, [r7, #4]
 8000276:	613b      	str	r3, [r7, #16]
xBlockLink *pxLink;

	if( pv )
 8000278:	687b      	ldr	r3, [r7, #4]
 800027a:	2b00      	cmp	r3, #0
 800027c:	d027      	beq.n	80002ce <vPortFree+0x62>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 800027e:	2310      	movs	r3, #16
 8000280:	425b      	negs	r3, r3
 8000282:	693a      	ldr	r2, [r7, #16]
 8000284:	4413      	add	r3, r2
 8000286:	613b      	str	r3, [r7, #16]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 8000288:	693b      	ldr	r3, [r7, #16]
 800028a:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
 800028c:	f000 f994 	bl	80005b8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 8000290:	68fb      	ldr	r3, [r7, #12]
 8000292:	685b      	ldr	r3, [r3, #4]
 8000294:	60bb      	str	r3, [r7, #8]
 8000296:	4b10      	ldr	r3, [pc, #64]	; (80002d8 <vPortFree+0x6c>)
 8000298:	617b      	str	r3, [r7, #20]
 800029a:	e002      	b.n	80002a2 <vPortFree+0x36>
 800029c:	697b      	ldr	r3, [r7, #20]
 800029e:	681b      	ldr	r3, [r3, #0]
 80002a0:	617b      	str	r3, [r7, #20]
 80002a2:	697b      	ldr	r3, [r7, #20]
 80002a4:	681b      	ldr	r3, [r3, #0]
 80002a6:	685a      	ldr	r2, [r3, #4]
 80002a8:	68bb      	ldr	r3, [r7, #8]
 80002aa:	429a      	cmp	r2, r3
 80002ac:	d3f6      	bcc.n	800029c <vPortFree+0x30>
 80002ae:	697b      	ldr	r3, [r7, #20]
 80002b0:	681a      	ldr	r2, [r3, #0]
 80002b2:	68fb      	ldr	r3, [r7, #12]
 80002b4:	601a      	str	r2, [r3, #0]
 80002b6:	697b      	ldr	r3, [r7, #20]
 80002b8:	68fa      	ldr	r2, [r7, #12]
 80002ba:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
 80002bc:	68fb      	ldr	r3, [r7, #12]
 80002be:	685a      	ldr	r2, [r3, #4]
 80002c0:	4b06      	ldr	r3, [pc, #24]	; (80002dc <vPortFree+0x70>)
 80002c2:	681b      	ldr	r3, [r3, #0]
 80002c4:	4413      	add	r3, r2
 80002c6:	4a05      	ldr	r2, [pc, #20]	; (80002dc <vPortFree+0x70>)
 80002c8:	6013      	str	r3, [r2, #0]
		}
		xTaskResumeAll();
 80002ca:	f000 f983 	bl	80005d4 <xTaskResumeAll>
	}
}
 80002ce:	bf00      	nop
 80002d0:	3718      	adds	r7, #24
 80002d2:	46bd      	mov	sp, r7
 80002d4:	bd80      	pop	{r7, pc}
 80002d6:	bf00      	nop
 80002d8:	20001410 	.word	0x20001410
 80002dc:	20000000 	.word	0x20000000

080002e0 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 80002e0:	b480      	push	{r7}
 80002e2:	b085      	sub	sp, #20
 80002e4:	af00      	add	r7, sp, #0
 80002e6:	60f8      	str	r0, [r7, #12]
 80002e8:	60b9      	str	r1, [r7, #8]
 80002ea:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 80002ec:	68fb      	ldr	r3, [r7, #12]
 80002ee:	3b04      	subs	r3, #4
 80002f0:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80002f2:	68fb      	ldr	r3, [r7, #12]
 80002f4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80002f8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 80002fa:	68fb      	ldr	r3, [r7, #12]
 80002fc:	3b04      	subs	r3, #4
 80002fe:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8000300:	68ba      	ldr	r2, [r7, #8]
 8000302:	68fb      	ldr	r3, [r7, #12]
 8000304:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000306:	68fb      	ldr	r3, [r7, #12]
 8000308:	3b04      	subs	r3, #4
 800030a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
 800030c:	68fb      	ldr	r3, [r7, #12]
 800030e:	2200      	movs	r2, #0
 8000310:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8000312:	68fb      	ldr	r3, [r7, #12]
 8000314:	3b14      	subs	r3, #20
 8000316:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8000318:	687a      	ldr	r2, [r7, #4]
 800031a:	68fb      	ldr	r3, [r7, #12]
 800031c:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 800031e:	68fb      	ldr	r3, [r7, #12]
 8000320:	3b20      	subs	r3, #32
 8000322:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8000324:	68fb      	ldr	r3, [r7, #12]
}
 8000326:	4618      	mov	r0, r3
 8000328:	3714      	adds	r7, #20
 800032a:	46bd      	mov	sp, r7
 800032c:	bc80      	pop	{r7}
 800032e:	4770      	bx	lr

08000330 <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 8000330:	4804      	ldr	r0, [pc, #16]	; (8000344 <vPortStartFirstTask+0x14>)
 8000332:	6800      	ldr	r0, [r0, #0]
 8000334:	6800      	ldr	r0, [r0, #0]
 8000336:	f380 8808 	msr	MSP, r0
 800033a:	b662      	cpsie	i
 800033c:	df00      	svc	0
 800033e:	bf00      	nop
					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
					" cpsie i				\n" /* Globally enable interrupts. */
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 8000340:	bf00      	nop
 8000342:	0000      	.short	0x0000
 8000344:	e000ed08 	.word	0xe000ed08

08000348 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8000348:	b580      	push	{r7, lr}
 800034a:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800034c:	4a0a      	ldr	r2, [pc, #40]	; (8000378 <xPortStartScheduler+0x30>)
 800034e:	4b0a      	ldr	r3, [pc, #40]	; (8000378 <xPortStartScheduler+0x30>)
 8000350:	681b      	ldr	r3, [r3, #0]
 8000352:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8000356:	6013      	str	r3, [r2, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8000358:	4a07      	ldr	r2, [pc, #28]	; (8000378 <xPortStartScheduler+0x30>)
 800035a:	4b07      	ldr	r3, [pc, #28]	; (8000378 <xPortStartScheduler+0x30>)
 800035c:	681b      	ldr	r3, [r3, #0]
 800035e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 8000362:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 8000364:	f000 f840 	bl	80003e8 <prvSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8000368:	4b04      	ldr	r3, [pc, #16]	; (800037c <xPortStartScheduler+0x34>)
 800036a:	2200      	movs	r2, #0
 800036c:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 800036e:	f7ff ffdf 	bl	8000330 <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
 8000372:	2300      	movs	r3, #0
}
 8000374:	4618      	mov	r0, r3
 8000376:	bd80      	pop	{r7, pc}
 8000378:	e000ed20 	.word	0xe000ed20
 800037c:	20000004 	.word	0x20000004

08000380 <vPortYieldFromISR>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 8000380:	b480      	push	{r7}
 8000382:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8000384:	4b03      	ldr	r3, [pc, #12]	; (8000394 <vPortYieldFromISR+0x14>)
 8000386:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800038a:	601a      	str	r2, [r3, #0]
}
 800038c:	bf00      	nop
 800038e:	46bd      	mov	sp, r7
 8000390:	bc80      	pop	{r7}
 8000392:	4770      	bx	lr
 8000394:	e000ed04 	.word	0xe000ed04

08000398 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8000398:	b480      	push	{r7}
 800039a:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 800039c:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 80003a0:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 80003a4:	4b04      	ldr	r3, [pc, #16]	; (80003b8 <vPortEnterCritical+0x20>)
 80003a6:	681b      	ldr	r3, [r3, #0]
 80003a8:	3301      	adds	r3, #1
 80003aa:	4a03      	ldr	r2, [pc, #12]	; (80003b8 <vPortEnterCritical+0x20>)
 80003ac:	6013      	str	r3, [r2, #0]
}
 80003ae:	bf00      	nop
 80003b0:	46bd      	mov	sp, r7
 80003b2:	bc80      	pop	{r7}
 80003b4:	4770      	bx	lr
 80003b6:	bf00      	nop
 80003b8:	20000004 	.word	0x20000004

080003bc <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 80003bc:	b480      	push	{r7}
 80003be:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
 80003c0:	4b08      	ldr	r3, [pc, #32]	; (80003e4 <vPortExitCritical+0x28>)
 80003c2:	681b      	ldr	r3, [r3, #0]
 80003c4:	3b01      	subs	r3, #1
 80003c6:	4a07      	ldr	r2, [pc, #28]	; (80003e4 <vPortExitCritical+0x28>)
 80003c8:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 80003ca:	4b06      	ldr	r3, [pc, #24]	; (80003e4 <vPortExitCritical+0x28>)
 80003cc:	681b      	ldr	r3, [r3, #0]
 80003ce:	2b00      	cmp	r3, #0
 80003d0:	d103      	bne.n	80003da <vPortExitCritical+0x1e>
	{
		portENABLE_INTERRUPTS();
 80003d2:	f04f 0000 	mov.w	r0, #0
 80003d6:	f380 8811 	msr	BASEPRI, r0
	}
}
 80003da:	bf00      	nop
 80003dc:	46bd      	mov	sp, r7
 80003de:	bc80      	pop	{r7}
 80003e0:	4770      	bx	lr
 80003e2:	bf00      	nop
 80003e4:	20000004 	.word	0x20000004

080003e8 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 80003e8:	b480      	push	{r7}
 80003ea:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80003ec:	4b04      	ldr	r3, [pc, #16]	; (8000400 <prvSetupTimerInterrupt+0x18>)
 80003ee:	4a05      	ldr	r2, [pc, #20]	; (8000404 <prvSetupTimerInterrupt+0x1c>)
 80003f0:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 80003f2:	4b05      	ldr	r3, [pc, #20]	; (8000408 <prvSetupTimerInterrupt+0x20>)
 80003f4:	2207      	movs	r2, #7
 80003f6:	601a      	str	r2, [r3, #0]
}
 80003f8:	bf00      	nop
 80003fa:	46bd      	mov	sp, r7
 80003fc:	bc80      	pop	{r7}
 80003fe:	4770      	bx	lr
 8000400:	e000e014 	.word	0xe000e014
 8000404:	0001193f 	.word	0x0001193f
 8000408:	e000e010 	.word	0xe000e010

0800040c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 800040c:	b580      	push	{r7, lr}
 800040e:	b08a      	sub	sp, #40	; 0x28
 8000410:	af02      	add	r7, sp, #8
 8000412:	60f8      	str	r0, [r7, #12]
 8000414:	60b9      	str	r1, [r7, #8]
 8000416:	603b      	str	r3, [r7, #0]
 8000418:	4613      	mov	r3, r2
 800041a:	80fb      	strh	r3, [r7, #6]
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 800041c:	88fb      	ldrh	r3, [r7, #6]
 800041e:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8000420:	4618      	mov	r0, r3
 8000422:	f000 fa6b 	bl	80008fc <prvAllocateTCBAndStack>
 8000426:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
 8000428:	69bb      	ldr	r3, [r7, #24]
 800042a:	2b00      	cmp	r3, #0
 800042c:	d070      	beq.n	8000510 <xTaskGenericCreate+0x104>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 800042e:	69bb      	ldr	r3, [r7, #24]
 8000430:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000432:	88fb      	ldrh	r3, [r7, #6]
 8000434:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8000438:	3b01      	subs	r3, #1
 800043a:	009b      	lsls	r3, r3, #2
 800043c:	4413      	add	r3, r2
 800043e:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
 8000440:	697b      	ldr	r3, [r7, #20]
 8000442:	f023 0307 	bic.w	r3, r3, #7
 8000446:	617b      	str	r3, [r7, #20]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 8000448:	88fb      	ldrh	r3, [r7, #6]
 800044a:	9300      	str	r3, [sp, #0]
 800044c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800044e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8000450:	68b9      	ldr	r1, [r7, #8]
 8000452:	69b8      	ldr	r0, [r7, #24]
 8000454:	f000 f9de 	bl	8000814 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8000458:	683a      	ldr	r2, [r7, #0]
 800045a:	68f9      	ldr	r1, [r7, #12]
 800045c:	6978      	ldr	r0, [r7, #20]
 800045e:	f7ff ff3f 	bl	80002e0 <pxPortInitialiseStack>
 8000462:	4602      	mov	r2, r0
 8000464:	69bb      	ldr	r3, [r7, #24]
 8000466:	601a      	str	r2, [r3, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
 8000468:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800046a:	2b00      	cmp	r3, #0
 800046c:	d002      	beq.n	8000474 <xTaskGenericCreate+0x68>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 800046e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000470:	69ba      	ldr	r2, [r7, #24]
 8000472:	601a      	str	r2, [r3, #0]
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 8000474:	f7ff ff90 	bl	8000398 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8000478:	4b31      	ldr	r3, [pc, #196]	; (8000540 <xTaskGenericCreate+0x134>)
 800047a:	681b      	ldr	r3, [r3, #0]
 800047c:	3301      	adds	r3, #1
 800047e:	4a30      	ldr	r2, [pc, #192]	; (8000540 <xTaskGenericCreate+0x134>)
 8000480:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
 8000482:	4b30      	ldr	r3, [pc, #192]	; (8000544 <xTaskGenericCreate+0x138>)
 8000484:	681b      	ldr	r3, [r3, #0]
 8000486:	2b00      	cmp	r3, #0
 8000488:	d109      	bne.n	800049e <xTaskGenericCreate+0x92>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 800048a:	4a2e      	ldr	r2, [pc, #184]	; (8000544 <xTaskGenericCreate+0x138>)
 800048c:	69bb      	ldr	r3, [r7, #24]
 800048e:	6013      	str	r3, [r2, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 8000490:	4b2b      	ldr	r3, [pc, #172]	; (8000540 <xTaskGenericCreate+0x134>)
 8000492:	681b      	ldr	r3, [r3, #0]
 8000494:	2b01      	cmp	r3, #1
 8000496:	d10f      	bne.n	80004b8 <xTaskGenericCreate+0xac>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 8000498:	f000 f9f0 	bl	800087c <prvInitialiseTaskLists>
 800049c:	e00c      	b.n	80004b8 <xTaskGenericCreate+0xac>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 800049e:	4b2a      	ldr	r3, [pc, #168]	; (8000548 <xTaskGenericCreate+0x13c>)
 80004a0:	681b      	ldr	r3, [r3, #0]
 80004a2:	2b00      	cmp	r3, #0
 80004a4:	d108      	bne.n	80004b8 <xTaskGenericCreate+0xac>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 80004a6:	4b27      	ldr	r3, [pc, #156]	; (8000544 <xTaskGenericCreate+0x138>)
 80004a8:	681b      	ldr	r3, [r3, #0]
 80004aa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80004ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80004ae:	429a      	cmp	r2, r3
 80004b0:	d802      	bhi.n	80004b8 <xTaskGenericCreate+0xac>
					{
						pxCurrentTCB = pxNewTCB;
 80004b2:	4a24      	ldr	r2, [pc, #144]	; (8000544 <xTaskGenericCreate+0x138>)
 80004b4:	69bb      	ldr	r3, [r7, #24]
 80004b6:	6013      	str	r3, [r2, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 80004b8:	69bb      	ldr	r3, [r7, #24]
 80004ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80004bc:	4b23      	ldr	r3, [pc, #140]	; (800054c <xTaskGenericCreate+0x140>)
 80004be:	681b      	ldr	r3, [r3, #0]
 80004c0:	429a      	cmp	r2, r3
 80004c2:	d903      	bls.n	80004cc <xTaskGenericCreate+0xc0>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 80004c4:	69bb      	ldr	r3, [r7, #24]
 80004c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80004c8:	4a20      	ldr	r2, [pc, #128]	; (800054c <xTaskGenericCreate+0x140>)
 80004ca:	6013      	str	r3, [r2, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 80004cc:	4b20      	ldr	r3, [pc, #128]	; (8000550 <xTaskGenericCreate+0x144>)
 80004ce:	681b      	ldr	r3, [r3, #0]
 80004d0:	3301      	adds	r3, #1
 80004d2:	4a1f      	ldr	r2, [pc, #124]	; (8000550 <xTaskGenericCreate+0x144>)
 80004d4:	6013      	str	r3, [r2, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 80004d6:	69bb      	ldr	r3, [r7, #24]
 80004d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80004da:	4b1e      	ldr	r3, [pc, #120]	; (8000554 <xTaskGenericCreate+0x148>)
 80004dc:	681b      	ldr	r3, [r3, #0]
 80004de:	429a      	cmp	r2, r3
 80004e0:	d903      	bls.n	80004ea <xTaskGenericCreate+0xde>
 80004e2:	69bb      	ldr	r3, [r7, #24]
 80004e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80004e6:	4a1b      	ldr	r2, [pc, #108]	; (8000554 <xTaskGenericCreate+0x148>)
 80004e8:	6013      	str	r3, [r2, #0]
 80004ea:	69bb      	ldr	r3, [r7, #24]
 80004ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80004ee:	4613      	mov	r3, r2
 80004f0:	009b      	lsls	r3, r3, #2
 80004f2:	4413      	add	r3, r2
 80004f4:	009b      	lsls	r3, r3, #2
 80004f6:	4a18      	ldr	r2, [pc, #96]	; (8000558 <xTaskGenericCreate+0x14c>)
 80004f8:	441a      	add	r2, r3
 80004fa:	69bb      	ldr	r3, [r7, #24]
 80004fc:	3304      	adds	r3, #4
 80004fe:	4619      	mov	r1, r3
 8000500:	4610      	mov	r0, r2
 8000502:	f000 fa4e 	bl	80009a2 <vListInsertEnd>

			xReturn = pdPASS;
 8000506:	2301      	movs	r3, #1
 8000508:	61fb      	str	r3, [r7, #28]
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 800050a:	f7ff ff57 	bl	80003bc <vPortExitCritical>
 800050e:	e002      	b.n	8000516 <xTaskGenericCreate+0x10a>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8000510:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000514:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
 8000516:	69fb      	ldr	r3, [r7, #28]
 8000518:	2b01      	cmp	r3, #1
 800051a:	d10b      	bne.n	8000534 <xTaskGenericCreate+0x128>
	{
		if( xSchedulerRunning != pdFALSE )
 800051c:	4b0a      	ldr	r3, [pc, #40]	; (8000548 <xTaskGenericCreate+0x13c>)
 800051e:	681b      	ldr	r3, [r3, #0]
 8000520:	2b00      	cmp	r3, #0
 8000522:	d007      	beq.n	8000534 <xTaskGenericCreate+0x128>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8000524:	4b07      	ldr	r3, [pc, #28]	; (8000544 <xTaskGenericCreate+0x138>)
 8000526:	681b      	ldr	r3, [r3, #0]
 8000528:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800052a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800052c:	429a      	cmp	r2, r3
 800052e:	d201      	bcs.n	8000534 <xTaskGenericCreate+0x128>
			{
				portYIELD_WITHIN_API();
 8000530:	f7ff ff26 	bl	8000380 <vPortYieldFromISR>
			}
		}
	}

	return xReturn;
 8000534:	69fb      	ldr	r3, [r7, #28]
}
 8000536:	4618      	mov	r0, r3
 8000538:	3720      	adds	r7, #32
 800053a:	46bd      	mov	sp, r7
 800053c:	bd80      	pop	{r7, pc}
 800053e:	bf00      	nop
 8000540:	200014e4 	.word	0x200014e4
 8000544:	20001424 	.word	0x20001424
 8000548:	200014f4 	.word	0x200014f4
 800054c:	200014ec 	.word	0x200014ec
 8000550:	20001508 	.word	0x20001508
 8000554:	200014f0 	.word	0x200014f0
 8000558:	20001428 	.word	0x20001428

0800055c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 800055c:	b580      	push	{r7, lr}
 800055e:	b086      	sub	sp, #24
 8000560:	af04      	add	r7, sp, #16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
 8000562:	2300      	movs	r3, #0
 8000564:	9303      	str	r3, [sp, #12]
 8000566:	2300      	movs	r3, #0
 8000568:	9302      	str	r3, [sp, #8]
 800056a:	2300      	movs	r3, #0
 800056c:	9301      	str	r3, [sp, #4]
 800056e:	2300      	movs	r3, #0
 8000570:	9300      	str	r3, [sp, #0]
 8000572:	2300      	movs	r3, #0
 8000574:	220a      	movs	r2, #10
 8000576:	490c      	ldr	r1, [pc, #48]	; (80005a8 <vTaskStartScheduler+0x4c>)
 8000578:	480c      	ldr	r0, [pc, #48]	; (80005ac <vTaskStartScheduler+0x50>)
 800057a:	f7ff ff47 	bl	800040c <xTaskGenericCreate>
 800057e:	6078      	str	r0, [r7, #4]
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
 8000580:	687b      	ldr	r3, [r7, #4]
 8000582:	2b01      	cmp	r3, #1
 8000584:	d10b      	bne.n	800059e <vTaskStartScheduler+0x42>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 8000586:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 800058a:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 800058e:	4b08      	ldr	r3, [pc, #32]	; (80005b0 <vTaskStartScheduler+0x54>)
 8000590:	2201      	movs	r2, #1
 8000592:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
 8000594:	4b07      	ldr	r3, [pc, #28]	; (80005b4 <vTaskStartScheduler+0x58>)
 8000596:	2200      	movs	r2, #0
 8000598:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800059a:	f7ff fed5 	bl	8000348 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
 800059e:	bf00      	nop
 80005a0:	3708      	adds	r7, #8
 80005a2:	46bd      	mov	sp, r7
 80005a4:	bd80      	pop	{r7, pc}
 80005a6:	bf00      	nop
 80005a8:	08000014 	.word	0x08000014
 80005ac:	080007f5 	.word	0x080007f5
 80005b0:	200014f4 	.word	0x200014f4
 80005b4:	200014e8 	.word	0x200014e8

080005b8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 80005b8:	b480      	push	{r7}
 80005ba:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 80005bc:	4b04      	ldr	r3, [pc, #16]	; (80005d0 <vTaskSuspendAll+0x18>)
 80005be:	681b      	ldr	r3, [r3, #0]
 80005c0:	3301      	adds	r3, #1
 80005c2:	4a03      	ldr	r2, [pc, #12]	; (80005d0 <vTaskSuspendAll+0x18>)
 80005c4:	6013      	str	r3, [r2, #0]
}
 80005c6:	bf00      	nop
 80005c8:	46bd      	mov	sp, r7
 80005ca:	bc80      	pop	{r7}
 80005cc:	4770      	bx	lr
 80005ce:	bf00      	nop
 80005d0:	200014f8 	.word	0x200014f8

080005d4 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 80005d4:	b590      	push	{r4, r7, lr}
 80005d6:	b083      	sub	sp, #12
 80005d8:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80005da:	2300      	movs	r3, #0
 80005dc:	607b      	str	r3, [r7, #4]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80005de:	f7ff fedb 	bl	8000398 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80005e2:	4b31      	ldr	r3, [pc, #196]	; (80006a8 <xTaskResumeAll+0xd4>)
 80005e4:	681b      	ldr	r3, [r3, #0]
 80005e6:	3b01      	subs	r3, #1
 80005e8:	4a2f      	ldr	r2, [pc, #188]	; (80006a8 <xTaskResumeAll+0xd4>)
 80005ea:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80005ec:	4b2e      	ldr	r3, [pc, #184]	; (80006a8 <xTaskResumeAll+0xd4>)
 80005ee:	681b      	ldr	r3, [r3, #0]
 80005f0:	2b00      	cmp	r3, #0
 80005f2:	d152      	bne.n	800069a <xTaskResumeAll+0xc6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 80005f4:	4b2d      	ldr	r3, [pc, #180]	; (80006ac <xTaskResumeAll+0xd8>)
 80005f6:	681b      	ldr	r3, [r3, #0]
 80005f8:	2b00      	cmp	r3, #0
 80005fa:	d04e      	beq.n	800069a <xTaskResumeAll+0xc6>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 80005fc:	2300      	movs	r3, #0
 80005fe:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 8000600:	e027      	b.n	8000652 <xTaskResumeAll+0x7e>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 8000602:	4b2b      	ldr	r3, [pc, #172]	; (80006b0 <xTaskResumeAll+0xdc>)
 8000604:	68db      	ldr	r3, [r3, #12]
 8000606:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xEventListItem ) );
 8000608:	f104 0318 	add.w	r3, r4, #24
 800060c:	4618      	mov	r0, r3
 800060e:	f000 f9ef 	bl	80009f0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 8000612:	1d23      	adds	r3, r4, #4
 8000614:	4618      	mov	r0, r3
 8000616:	f000 f9eb 	bl	80009f0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 800061a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800061c:	4b25      	ldr	r3, [pc, #148]	; (80006b4 <xTaskResumeAll+0xe0>)
 800061e:	681b      	ldr	r3, [r3, #0]
 8000620:	429a      	cmp	r2, r3
 8000622:	d902      	bls.n	800062a <xTaskResumeAll+0x56>
 8000624:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000626:	4a23      	ldr	r2, [pc, #140]	; (80006b4 <xTaskResumeAll+0xe0>)
 8000628:	6013      	str	r3, [r2, #0]
 800062a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800062c:	4613      	mov	r3, r2
 800062e:	009b      	lsls	r3, r3, #2
 8000630:	4413      	add	r3, r2
 8000632:	009b      	lsls	r3, r3, #2
 8000634:	4a20      	ldr	r2, [pc, #128]	; (80006b8 <xTaskResumeAll+0xe4>)
 8000636:	4413      	add	r3, r2
 8000638:	1d22      	adds	r2, r4, #4
 800063a:	4611      	mov	r1, r2
 800063c:	4618      	mov	r0, r3
 800063e:	f000 f9b0 	bl	80009a2 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000642:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000644:	4b1d      	ldr	r3, [pc, #116]	; (80006bc <xTaskResumeAll+0xe8>)
 8000646:	681b      	ldr	r3, [r3, #0]
 8000648:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800064a:	429a      	cmp	r2, r3
 800064c:	d301      	bcc.n	8000652 <xTaskResumeAll+0x7e>
					{
						xYieldRequired = pdTRUE;
 800064e:	2301      	movs	r3, #1
 8000650:	603b      	str	r3, [r7, #0]
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 8000652:	4b17      	ldr	r3, [pc, #92]	; (80006b0 <xTaskResumeAll+0xdc>)
 8000654:	681b      	ldr	r3, [r3, #0]
 8000656:	2b00      	cmp	r3, #0
 8000658:	d1d3      	bne.n	8000602 <xTaskResumeAll+0x2e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 800065a:	4b19      	ldr	r3, [pc, #100]	; (80006c0 <xTaskResumeAll+0xec>)
 800065c:	681b      	ldr	r3, [r3, #0]
 800065e:	2b00      	cmp	r3, #0
 8000660:	d00d      	beq.n	800067e <xTaskResumeAll+0xaa>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 8000662:	e006      	b.n	8000672 <xTaskResumeAll+0x9e>
					{
						vTaskIncrementTick();
 8000664:	f000 f830 	bl	80006c8 <vTaskIncrementTick>
						--uxMissedTicks;
 8000668:	4b15      	ldr	r3, [pc, #84]	; (80006c0 <xTaskResumeAll+0xec>)
 800066a:	681b      	ldr	r3, [r3, #0]
 800066c:	3b01      	subs	r3, #1
 800066e:	4a14      	ldr	r2, [pc, #80]	; (80006c0 <xTaskResumeAll+0xec>)
 8000670:	6013      	str	r3, [r2, #0]
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 8000672:	4b13      	ldr	r3, [pc, #76]	; (80006c0 <xTaskResumeAll+0xec>)
 8000674:	681b      	ldr	r3, [r3, #0]
 8000676:	2b00      	cmp	r3, #0
 8000678:	d1f4      	bne.n	8000664 <xTaskResumeAll+0x90>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 800067a:	2301      	movs	r3, #1
 800067c:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 800067e:	683b      	ldr	r3, [r7, #0]
 8000680:	2b01      	cmp	r3, #1
 8000682:	d003      	beq.n	800068c <xTaskResumeAll+0xb8>
 8000684:	4b0f      	ldr	r3, [pc, #60]	; (80006c4 <xTaskResumeAll+0xf0>)
 8000686:	681b      	ldr	r3, [r3, #0]
 8000688:	2b01      	cmp	r3, #1
 800068a:	d106      	bne.n	800069a <xTaskResumeAll+0xc6>
				{
					xAlreadyYielded = pdTRUE;
 800068c:	2301      	movs	r3, #1
 800068e:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
 8000690:	4b0c      	ldr	r3, [pc, #48]	; (80006c4 <xTaskResumeAll+0xf0>)
 8000692:	2200      	movs	r2, #0
 8000694:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 8000696:	f7ff fe73 	bl	8000380 <vPortYieldFromISR>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 800069a:	f7ff fe8f 	bl	80003bc <vPortExitCritical>

	return xAlreadyYielded;
 800069e:	687b      	ldr	r3, [r7, #4]
}
 80006a0:	4618      	mov	r0, r3
 80006a2:	370c      	adds	r7, #12
 80006a4:	46bd      	mov	sp, r7
 80006a6:	bd90      	pop	{r4, r7, pc}
 80006a8:	200014f8 	.word	0x200014f8
 80006ac:	200014e4 	.word	0x200014e4
 80006b0:	200014bc 	.word	0x200014bc
 80006b4:	200014f0 	.word	0x200014f0
 80006b8:	20001428 	.word	0x20001428
 80006bc:	20001424 	.word	0x20001424
 80006c0:	200014fc 	.word	0x200014fc
 80006c4:	20001500 	.word	0x20001500

080006c8 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 80006c8:	b580      	push	{r7, lr}
 80006ca:	b084      	sub	sp, #16
 80006cc:	af00      	add	r7, sp, #0
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80006ce:	4b40      	ldr	r3, [pc, #256]	; (80007d0 <vTaskIncrementTick+0x108>)
 80006d0:	681b      	ldr	r3, [r3, #0]
 80006d2:	2b00      	cmp	r3, #0
 80006d4:	d172      	bne.n	80007bc <vTaskIncrementTick+0xf4>
	{
		++xTickCount;
 80006d6:	4b3f      	ldr	r3, [pc, #252]	; (80007d4 <vTaskIncrementTick+0x10c>)
 80006d8:	681b      	ldr	r3, [r3, #0]
 80006da:	3301      	adds	r3, #1
 80006dc:	4a3d      	ldr	r2, [pc, #244]	; (80007d4 <vTaskIncrementTick+0x10c>)
 80006de:	6013      	str	r3, [r2, #0]
		if( xTickCount == ( portTickType ) 0U )
 80006e0:	4b3c      	ldr	r3, [pc, #240]	; (80007d4 <vTaskIncrementTick+0x10c>)
 80006e2:	681b      	ldr	r3, [r3, #0]
 80006e4:	2b00      	cmp	r3, #0
 80006e6:	d121      	bne.n	800072c <vTaskIncrementTick+0x64>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
 80006e8:	4b3b      	ldr	r3, [pc, #236]	; (80007d8 <vTaskIncrementTick+0x110>)
 80006ea:	681b      	ldr	r3, [r3, #0]
 80006ec:	60fb      	str	r3, [r7, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 80006ee:	4b3b      	ldr	r3, [pc, #236]	; (80007dc <vTaskIncrementTick+0x114>)
 80006f0:	681b      	ldr	r3, [r3, #0]
 80006f2:	4a39      	ldr	r2, [pc, #228]	; (80007d8 <vTaskIncrementTick+0x110>)
 80006f4:	6013      	str	r3, [r2, #0]
			pxOverflowDelayedTaskList = pxTemp;
 80006f6:	4a39      	ldr	r2, [pc, #228]	; (80007dc <vTaskIncrementTick+0x114>)
 80006f8:	68fb      	ldr	r3, [r7, #12]
 80006fa:	6013      	str	r3, [r2, #0]
			xNumOfOverflows++;
 80006fc:	4b38      	ldr	r3, [pc, #224]	; (80007e0 <vTaskIncrementTick+0x118>)
 80006fe:	681b      	ldr	r3, [r3, #0]
 8000700:	3301      	adds	r3, #1
 8000702:	4a37      	ldr	r2, [pc, #220]	; (80007e0 <vTaskIncrementTick+0x118>)
 8000704:	6013      	str	r3, [r2, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000706:	4b34      	ldr	r3, [pc, #208]	; (80007d8 <vTaskIncrementTick+0x110>)
 8000708:	681b      	ldr	r3, [r3, #0]
 800070a:	681b      	ldr	r3, [r3, #0]
 800070c:	2b00      	cmp	r3, #0
 800070e:	d104      	bne.n	800071a <vTaskIncrementTick+0x52>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 8000710:	4b34      	ldr	r3, [pc, #208]	; (80007e4 <vTaskIncrementTick+0x11c>)
 8000712:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000716:	601a      	str	r2, [r3, #0]
 8000718:	e008      	b.n	800072c <vTaskIncrementTick+0x64>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800071a:	4b2f      	ldr	r3, [pc, #188]	; (80007d8 <vTaskIncrementTick+0x110>)
 800071c:	681b      	ldr	r3, [r3, #0]
 800071e:	68db      	ldr	r3, [r3, #12]
 8000720:	68db      	ldr	r3, [r3, #12]
 8000722:	60bb      	str	r3, [r7, #8]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8000724:	68bb      	ldr	r3, [r7, #8]
 8000726:	685b      	ldr	r3, [r3, #4]
 8000728:	4a2e      	ldr	r2, [pc, #184]	; (80007e4 <vTaskIncrementTick+0x11c>)
 800072a:	6013      	str	r3, [r2, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 800072c:	4b29      	ldr	r3, [pc, #164]	; (80007d4 <vTaskIncrementTick+0x10c>)
 800072e:	681a      	ldr	r2, [r3, #0]
 8000730:	4b2c      	ldr	r3, [pc, #176]	; (80007e4 <vTaskIncrementTick+0x11c>)
 8000732:	681b      	ldr	r3, [r3, #0]
 8000734:	429a      	cmp	r2, r3
 8000736:	d347      	bcc.n	80007c8 <vTaskIncrementTick+0x100>
 8000738:	4b27      	ldr	r3, [pc, #156]	; (80007d8 <vTaskIncrementTick+0x110>)
 800073a:	681b      	ldr	r3, [r3, #0]
 800073c:	681b      	ldr	r3, [r3, #0]
 800073e:	2b00      	cmp	r3, #0
 8000740:	d104      	bne.n	800074c <vTaskIncrementTick+0x84>
 8000742:	4b28      	ldr	r3, [pc, #160]	; (80007e4 <vTaskIncrementTick+0x11c>)
 8000744:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000748:	601a      	str	r2, [r3, #0]
 800074a:	e03d      	b.n	80007c8 <vTaskIncrementTick+0x100>
 800074c:	4b22      	ldr	r3, [pc, #136]	; (80007d8 <vTaskIncrementTick+0x110>)
 800074e:	681b      	ldr	r3, [r3, #0]
 8000750:	68db      	ldr	r3, [r3, #12]
 8000752:	68db      	ldr	r3, [r3, #12]
 8000754:	60bb      	str	r3, [r7, #8]
 8000756:	68bb      	ldr	r3, [r7, #8]
 8000758:	685b      	ldr	r3, [r3, #4]
 800075a:	607b      	str	r3, [r7, #4]
 800075c:	4b1d      	ldr	r3, [pc, #116]	; (80007d4 <vTaskIncrementTick+0x10c>)
 800075e:	681a      	ldr	r2, [r3, #0]
 8000760:	687b      	ldr	r3, [r7, #4]
 8000762:	429a      	cmp	r2, r3
 8000764:	d203      	bcs.n	800076e <vTaskIncrementTick+0xa6>
 8000766:	4a1f      	ldr	r2, [pc, #124]	; (80007e4 <vTaskIncrementTick+0x11c>)
 8000768:	687b      	ldr	r3, [r7, #4]
 800076a:	6013      	str	r3, [r2, #0]
 800076c:	e02c      	b.n	80007c8 <vTaskIncrementTick+0x100>
 800076e:	68bb      	ldr	r3, [r7, #8]
 8000770:	3304      	adds	r3, #4
 8000772:	4618      	mov	r0, r3
 8000774:	f000 f93c 	bl	80009f0 <vListRemove>
 8000778:	68bb      	ldr	r3, [r7, #8]
 800077a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800077c:	2b00      	cmp	r3, #0
 800077e:	d004      	beq.n	800078a <vTaskIncrementTick+0xc2>
 8000780:	68bb      	ldr	r3, [r7, #8]
 8000782:	3318      	adds	r3, #24
 8000784:	4618      	mov	r0, r3
 8000786:	f000 f933 	bl	80009f0 <vListRemove>
 800078a:	68bb      	ldr	r3, [r7, #8]
 800078c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800078e:	4b16      	ldr	r3, [pc, #88]	; (80007e8 <vTaskIncrementTick+0x120>)
 8000790:	681b      	ldr	r3, [r3, #0]
 8000792:	429a      	cmp	r2, r3
 8000794:	d903      	bls.n	800079e <vTaskIncrementTick+0xd6>
 8000796:	68bb      	ldr	r3, [r7, #8]
 8000798:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800079a:	4a13      	ldr	r2, [pc, #76]	; (80007e8 <vTaskIncrementTick+0x120>)
 800079c:	6013      	str	r3, [r2, #0]
 800079e:	68bb      	ldr	r3, [r7, #8]
 80007a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80007a2:	4613      	mov	r3, r2
 80007a4:	009b      	lsls	r3, r3, #2
 80007a6:	4413      	add	r3, r2
 80007a8:	009b      	lsls	r3, r3, #2
 80007aa:	4a10      	ldr	r2, [pc, #64]	; (80007ec <vTaskIncrementTick+0x124>)
 80007ac:	441a      	add	r2, r3
 80007ae:	68bb      	ldr	r3, [r7, #8]
 80007b0:	3304      	adds	r3, #4
 80007b2:	4619      	mov	r1, r3
 80007b4:	4610      	mov	r0, r2
 80007b6:	f000 f8f4 	bl	80009a2 <vListInsertEnd>
 80007ba:	e7bd      	b.n	8000738 <vTaskIncrementTick+0x70>
	}
	else
	{
		++uxMissedTicks;
 80007bc:	4b0c      	ldr	r3, [pc, #48]	; (80007f0 <vTaskIncrementTick+0x128>)
 80007be:	681b      	ldr	r3, [r3, #0]
 80007c0:	3301      	adds	r3, #1
 80007c2:	4a0b      	ldr	r2, [pc, #44]	; (80007f0 <vTaskIncrementTick+0x128>)
 80007c4:	6013      	str	r3, [r2, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 80007c6:	e7ff      	b.n	80007c8 <vTaskIncrementTick+0x100>
 80007c8:	bf00      	nop
 80007ca:	3710      	adds	r7, #16
 80007cc:	46bd      	mov	sp, r7
 80007ce:	bd80      	pop	{r7, pc}
 80007d0:	200014f8 	.word	0x200014f8
 80007d4:	200014e8 	.word	0x200014e8
 80007d8:	200014b4 	.word	0x200014b4
 80007dc:	200014b8 	.word	0x200014b8
 80007e0:	20001504 	.word	0x20001504
 80007e4:	20000008 	.word	0x20000008
 80007e8:	200014f0 	.word	0x200014f0
 80007ec:	20001428 	.word	0x20001428
 80007f0:	200014fc 	.word	0x200014fc

080007f4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 80007f4:	b580      	push	{r7, lr}
 80007f6:	b082      	sub	sp, #8
 80007f8:	af00      	add	r7, sp, #0
 80007fa:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 80007fc:	f000 f878 	bl	80008f0 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8000800:	4b03      	ldr	r3, [pc, #12]	; (8000810 <prvIdleTask+0x1c>)
 8000802:	681b      	ldr	r3, [r3, #0]
 8000804:	2b01      	cmp	r3, #1
 8000806:	d9f9      	bls.n	80007fc <prvIdleTask+0x8>
			{
				taskYIELD();
 8000808:	f7ff fdba 	bl	8000380 <vPortYieldFromISR>
		prvCheckTasksWaitingTermination();
 800080c:	e7f6      	b.n	80007fc <prvIdleTask+0x8>
 800080e:	bf00      	nop
 8000810:	20001428 	.word	0x20001428

08000814 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 8000814:	b580      	push	{r7, lr}
 8000816:	b084      	sub	sp, #16
 8000818:	af00      	add	r7, sp, #0
 800081a:	60f8      	str	r0, [r7, #12]
 800081c:	60b9      	str	r1, [r7, #8]
 800081e:	607a      	str	r2, [r7, #4]
 8000820:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8000822:	68fb      	ldr	r3, [r7, #12]
 8000824:	3334      	adds	r3, #52	; 0x34
 8000826:	2210      	movs	r2, #16
 8000828:	68b9      	ldr	r1, [r7, #8]
 800082a:	4618      	mov	r0, r3
 800082c:	f000 f908 	bl	8000a40 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 8000830:	68fb      	ldr	r3, [r7, #12]
 8000832:	2200      	movs	r2, #0
 8000834:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 8000838:	687b      	ldr	r3, [r7, #4]
 800083a:	2b04      	cmp	r3, #4
 800083c:	d901      	bls.n	8000842 <prvInitialiseTCBVariables+0x2e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 800083e:	2304      	movs	r3, #4
 8000840:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
 8000842:	68fb      	ldr	r3, [r7, #12]
 8000844:	687a      	ldr	r2, [r7, #4]
 8000846:	62da      	str	r2, [r3, #44]	; 0x2c
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8000848:	68fb      	ldr	r3, [r7, #12]
 800084a:	3304      	adds	r3, #4
 800084c:	4618      	mov	r0, r3
 800084e:	f000 f89c 	bl	800098a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8000852:	68fb      	ldr	r3, [r7, #12]
 8000854:	3318      	adds	r3, #24
 8000856:	4618      	mov	r0, r3
 8000858:	f000 f897 	bl	800098a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 800085c:	68fb      	ldr	r3, [r7, #12]
 800085e:	68fa      	ldr	r2, [r7, #12]
 8000860:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8000862:	687b      	ldr	r3, [r7, #4]
 8000864:	f1c3 0205 	rsb	r2, r3, #5
 8000868:	68fb      	ldr	r3, [r7, #12]
 800086a:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 800086c:	68fb      	ldr	r3, [r7, #12]
 800086e:	68fa      	ldr	r2, [r7, #12]
 8000870:	625a      	str	r2, [r3, #36]	; 0x24
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 8000872:	bf00      	nop
 8000874:	3710      	adds	r7, #16
 8000876:	46bd      	mov	sp, r7
 8000878:	bd80      	pop	{r7, pc}
	...

0800087c <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 800087c:	b580      	push	{r7, lr}
 800087e:	b082      	sub	sp, #8
 8000880:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8000882:	2300      	movs	r3, #0
 8000884:	607b      	str	r3, [r7, #4]
 8000886:	e00c      	b.n	80008a2 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8000888:	687a      	ldr	r2, [r7, #4]
 800088a:	4613      	mov	r3, r2
 800088c:	009b      	lsls	r3, r3, #2
 800088e:	4413      	add	r3, r2
 8000890:	009b      	lsls	r3, r3, #2
 8000892:	4a10      	ldr	r2, [pc, #64]	; (80008d4 <prvInitialiseTaskLists+0x58>)
 8000894:	4413      	add	r3, r2
 8000896:	4618      	mov	r0, r3
 8000898:	f000 f858 	bl	800094c <vListInitialise>
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800089c:	687b      	ldr	r3, [r7, #4]
 800089e:	3301      	adds	r3, #1
 80008a0:	607b      	str	r3, [r7, #4]
 80008a2:	687b      	ldr	r3, [r7, #4]
 80008a4:	2b04      	cmp	r3, #4
 80008a6:	d9ef      	bls.n	8000888 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 80008a8:	480b      	ldr	r0, [pc, #44]	; (80008d8 <prvInitialiseTaskLists+0x5c>)
 80008aa:	f000 f84f 	bl	800094c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 80008ae:	480b      	ldr	r0, [pc, #44]	; (80008dc <prvInitialiseTaskLists+0x60>)
 80008b0:	f000 f84c 	bl	800094c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 80008b4:	480a      	ldr	r0, [pc, #40]	; (80008e0 <prvInitialiseTaskLists+0x64>)
 80008b6:	f000 f849 	bl	800094c <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 80008ba:	480a      	ldr	r0, [pc, #40]	; (80008e4 <prvInitialiseTaskLists+0x68>)
 80008bc:	f000 f846 	bl	800094c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80008c0:	4b09      	ldr	r3, [pc, #36]	; (80008e8 <prvInitialiseTaskLists+0x6c>)
 80008c2:	4a05      	ldr	r2, [pc, #20]	; (80008d8 <prvInitialiseTaskLists+0x5c>)
 80008c4:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80008c6:	4b09      	ldr	r3, [pc, #36]	; (80008ec <prvInitialiseTaskLists+0x70>)
 80008c8:	4a04      	ldr	r2, [pc, #16]	; (80008dc <prvInitialiseTaskLists+0x60>)
 80008ca:	601a      	str	r2, [r3, #0]
}
 80008cc:	bf00      	nop
 80008ce:	3708      	adds	r7, #8
 80008d0:	46bd      	mov	sp, r7
 80008d2:	bd80      	pop	{r7, pc}
 80008d4:	20001428 	.word	0x20001428
 80008d8:	2000148c 	.word	0x2000148c
 80008dc:	200014a0 	.word	0x200014a0
 80008e0:	200014bc 	.word	0x200014bc
 80008e4:	200014d0 	.word	0x200014d0
 80008e8:	200014b4 	.word	0x200014b4
 80008ec:	200014b8 	.word	0x200014b8

080008f0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 80008f0:	b480      	push	{r7}
 80008f2:	af00      	add	r7, sp, #0
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
 80008f4:	bf00      	nop
 80008f6:	46bd      	mov	sp, r7
 80008f8:	bc80      	pop	{r7}
 80008fa:	4770      	bx	lr

080008fc <prvAllocateTCBAndStack>:
	}
}
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 80008fc:	b580      	push	{r7, lr}
 80008fe:	b084      	sub	sp, #16
 8000900:	af00      	add	r7, sp, #0
 8000902:	4603      	mov	r3, r0
 8000904:	6039      	str	r1, [r7, #0]
 8000906:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8000908:	2044      	movs	r0, #68	; 0x44
 800090a:	f7ff fc0d 	bl	8000128 <pvPortMalloc>
 800090e:	60f8      	str	r0, [r7, #12]

	if( pxNewTCB != NULL )
 8000910:	68fb      	ldr	r3, [r7, #12]
 8000912:	2b00      	cmp	r3, #0
 8000914:	d015      	beq.n	8000942 <prvAllocateTCBAndStack+0x46>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 8000916:	683b      	ldr	r3, [r7, #0]
 8000918:	2b00      	cmp	r3, #0
 800091a:	d106      	bne.n	800092a <prvAllocateTCBAndStack+0x2e>
 800091c:	88fb      	ldrh	r3, [r7, #6]
 800091e:	009b      	lsls	r3, r3, #2
 8000920:	4618      	mov	r0, r3
 8000922:	f7ff fc01 	bl	8000128 <pvPortMalloc>
 8000926:	4603      	mov	r3, r0
 8000928:	e000      	b.n	800092c <prvAllocateTCBAndStack+0x30>
 800092a:	683b      	ldr	r3, [r7, #0]
 800092c:	68fa      	ldr	r2, [r7, #12]
 800092e:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8000930:	68fb      	ldr	r3, [r7, #12]
 8000932:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000934:	2b00      	cmp	r3, #0
 8000936:	d104      	bne.n	8000942 <prvAllocateTCBAndStack+0x46>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8000938:	68f8      	ldr	r0, [r7, #12]
 800093a:	f7ff fc97 	bl	800026c <vPortFree>
			pxNewTCB = NULL;
 800093e:	2300      	movs	r3, #0
 8000940:	60fb      	str	r3, [r7, #12]
			/* Just to help debugging. */
			//memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
		}
	}

	return pxNewTCB;
 8000942:	68fb      	ldr	r3, [r7, #12]
}
 8000944:	4618      	mov	r0, r3
 8000946:	3710      	adds	r7, #16
 8000948:	46bd      	mov	sp, r7
 800094a:	bd80      	pop	{r7, pc}

0800094c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 800094c:	b480      	push	{r7}
 800094e:	b083      	sub	sp, #12
 8000950:	af00      	add	r7, sp, #0
 8000952:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8000954:	687b      	ldr	r3, [r7, #4]
 8000956:	f103 0208 	add.w	r2, r3, #8
 800095a:	687b      	ldr	r3, [r7, #4]
 800095c:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800095e:	687b      	ldr	r3, [r7, #4]
 8000960:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000964:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8000966:	687b      	ldr	r3, [r7, #4]
 8000968:	f103 0208 	add.w	r2, r3, #8
 800096c:	687b      	ldr	r3, [r7, #4]
 800096e:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8000970:	687b      	ldr	r3, [r7, #4]
 8000972:	f103 0208 	add.w	r2, r3, #8
 8000976:	687b      	ldr	r3, [r7, #4]
 8000978:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 800097a:	687b      	ldr	r3, [r7, #4]
 800097c:	2200      	movs	r2, #0
 800097e:	601a      	str	r2, [r3, #0]
}
 8000980:	bf00      	nop
 8000982:	370c      	adds	r7, #12
 8000984:	46bd      	mov	sp, r7
 8000986:	bc80      	pop	{r7}
 8000988:	4770      	bx	lr

0800098a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 800098a:	b480      	push	{r7}
 800098c:	b083      	sub	sp, #12
 800098e:	af00      	add	r7, sp, #0
 8000990:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8000992:	687b      	ldr	r3, [r7, #4]
 8000994:	2200      	movs	r2, #0
 8000996:	611a      	str	r2, [r3, #16]
}
 8000998:	bf00      	nop
 800099a:	370c      	adds	r7, #12
 800099c:	46bd      	mov	sp, r7
 800099e:	bc80      	pop	{r7}
 80009a0:	4770      	bx	lr

080009a2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 80009a2:	b480      	push	{r7}
 80009a4:	b085      	sub	sp, #20
 80009a6:	af00      	add	r7, sp, #0
 80009a8:	6078      	str	r0, [r7, #4]
 80009aa:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 80009ac:	687b      	ldr	r3, [r7, #4]
 80009ae:	685b      	ldr	r3, [r3, #4]
 80009b0:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 80009b2:	68fb      	ldr	r3, [r7, #12]
 80009b4:	685a      	ldr	r2, [r3, #4]
 80009b6:	683b      	ldr	r3, [r7, #0]
 80009b8:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 80009ba:	687b      	ldr	r3, [r7, #4]
 80009bc:	685a      	ldr	r2, [r3, #4]
 80009be:	683b      	ldr	r3, [r7, #0]
 80009c0:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 80009c2:	68fb      	ldr	r3, [r7, #12]
 80009c4:	685b      	ldr	r3, [r3, #4]
 80009c6:	683a      	ldr	r2, [r7, #0]
 80009c8:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 80009ca:	68fb      	ldr	r3, [r7, #12]
 80009cc:	683a      	ldr	r2, [r7, #0]
 80009ce:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 80009d0:	687b      	ldr	r3, [r7, #4]
 80009d2:	683a      	ldr	r2, [r7, #0]
 80009d4:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80009d6:	683b      	ldr	r3, [r7, #0]
 80009d8:	687a      	ldr	r2, [r7, #4]
 80009da:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 80009dc:	687b      	ldr	r3, [r7, #4]
 80009de:	681b      	ldr	r3, [r3, #0]
 80009e0:	1c5a      	adds	r2, r3, #1
 80009e2:	687b      	ldr	r3, [r7, #4]
 80009e4:	601a      	str	r2, [r3, #0]
}
 80009e6:	bf00      	nop
 80009e8:	3714      	adds	r7, #20
 80009ea:	46bd      	mov	sp, r7
 80009ec:	bc80      	pop	{r7}
 80009ee:	4770      	bx	lr

080009f0 <vListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 80009f0:	b480      	push	{r7}
 80009f2:	b085      	sub	sp, #20
 80009f4:	af00      	add	r7, sp, #0
 80009f6:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80009f8:	687b      	ldr	r3, [r7, #4]
 80009fa:	685b      	ldr	r3, [r3, #4]
 80009fc:	687a      	ldr	r2, [r7, #4]
 80009fe:	6892      	ldr	r2, [r2, #8]
 8000a00:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000a02:	687b      	ldr	r3, [r7, #4]
 8000a04:	689b      	ldr	r3, [r3, #8]
 8000a06:	687a      	ldr	r2, [r7, #4]
 8000a08:	6852      	ldr	r2, [r2, #4]
 8000a0a:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8000a0c:	687b      	ldr	r3, [r7, #4]
 8000a0e:	691b      	ldr	r3, [r3, #16]
 8000a10:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000a12:	68fb      	ldr	r3, [r7, #12]
 8000a14:	685a      	ldr	r2, [r3, #4]
 8000a16:	687b      	ldr	r3, [r7, #4]
 8000a18:	429a      	cmp	r2, r3
 8000a1a:	d103      	bne.n	8000a24 <vListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000a1c:	687b      	ldr	r3, [r7, #4]
 8000a1e:	689a      	ldr	r2, [r3, #8]
 8000a20:	68fb      	ldr	r3, [r7, #12]
 8000a22:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8000a24:	687b      	ldr	r3, [r7, #4]
 8000a26:	2200      	movs	r2, #0
 8000a28:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8000a2a:	68fb      	ldr	r3, [r7, #12]
 8000a2c:	681b      	ldr	r3, [r3, #0]
 8000a2e:	1e5a      	subs	r2, r3, #1
 8000a30:	68fb      	ldr	r3, [r7, #12]
 8000a32:	601a      	str	r2, [r3, #0]
}
 8000a34:	bf00      	nop
 8000a36:	3714      	adds	r7, #20
 8000a38:	46bd      	mov	sp, r7
 8000a3a:	bc80      	pop	{r7}
 8000a3c:	4770      	bx	lr
	...

08000a40 <strncpy>:
 8000a40:	ea40 0301 	orr.w	r3, r0, r1
 8000a44:	f013 0f03 	tst.w	r3, #3
 8000a48:	b470      	push	{r4, r5, r6}
 8000a4a:	4603      	mov	r3, r0
 8000a4c:	d024      	beq.n	8000a98 <strncpy+0x58>
 8000a4e:	b1a2      	cbz	r2, 8000a7a <strncpy+0x3a>
 8000a50:	780c      	ldrb	r4, [r1, #0]
 8000a52:	3a01      	subs	r2, #1
 8000a54:	701c      	strb	r4, [r3, #0]
 8000a56:	3101      	adds	r1, #1
 8000a58:	3301      	adds	r3, #1
 8000a5a:	b13c      	cbz	r4, 8000a6c <strncpy+0x2c>
 8000a5c:	b16a      	cbz	r2, 8000a7a <strncpy+0x3a>
 8000a5e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8000a62:	3a01      	subs	r2, #1
 8000a64:	f803 4b01 	strb.w	r4, [r3], #1
 8000a68:	2c00      	cmp	r4, #0
 8000a6a:	d1f7      	bne.n	8000a5c <strncpy+0x1c>
 8000a6c:	b12a      	cbz	r2, 8000a7a <strncpy+0x3a>
 8000a6e:	2100      	movs	r1, #0
 8000a70:	441a      	add	r2, r3
 8000a72:	f803 1b01 	strb.w	r1, [r3], #1
 8000a76:	429a      	cmp	r2, r3
 8000a78:	d1fb      	bne.n	8000a72 <strncpy+0x32>
 8000a7a:	bc70      	pop	{r4, r5, r6}
 8000a7c:	4770      	bx	lr
 8000a7e:	460e      	mov	r6, r1
 8000a80:	f851 5b04 	ldr.w	r5, [r1], #4
 8000a84:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
 8000a88:	ea24 0405 	bic.w	r4, r4, r5
 8000a8c:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 8000a90:	d105      	bne.n	8000a9e <strncpy+0x5e>
 8000a92:	3a04      	subs	r2, #4
 8000a94:	f843 5b04 	str.w	r5, [r3], #4
 8000a98:	2a03      	cmp	r2, #3
 8000a9a:	d8f0      	bhi.n	8000a7e <strncpy+0x3e>
 8000a9c:	e7d7      	b.n	8000a4e <strncpy+0xe>
 8000a9e:	4631      	mov	r1, r6
 8000aa0:	e7d6      	b.n	8000a50 <strncpy+0x10>
 8000aa2:	bf00      	nop

Disassembly of section .init:

08000aa4 <_init>:
 8000aa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000aa6:	bf00      	nop

Disassembly of section .fini:

08000aa8 <_fini>:
 8000aa8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000aaa:	bf00      	nop
